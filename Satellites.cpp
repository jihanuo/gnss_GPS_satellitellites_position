#pragma once
#include <iostream>
#include <regex>
#include <cctype>
#include "Satellites.h"
#include<iomanip>
#include <fstream>
#include <sstream>
#include <vector>
#include<string>
#include <ctime>

using namespace std;
#define U 3.986005e+14	// WGS-84 中地球引力常数
#define E 7.29211567e-5 // 地球自转速率


Satellites::Satellites(string path1, string path2, string path3)
{
	vector<string> prn;
	vector<vector<long double>> vt;								// 二维动态数组
	vector<long double> vi;										// 一维动态数组
	this->inFile.open(path1, ios::in);									// 打开文件
	this->oFile.open(path2, ios::out | ios::trunc);
	//读取文件数据

	if (this->inFile && this->oFile)													// 若文件打开成功则继续下面操作	
	{	
		cout << "开始读取数据" << endl;
		string s;												// 存放读取的每一行字符串
		smatch m;												// 存放正则匹配到的元素
		regex r("G\\d\\d.*|-?\\d.\\d{12}e[-+]\\d\\d");			// 正则匹配每个卫星单元
		regex r1("\\d{4}|\\d\\d|-?\\d\\.\\d{12}e[+-]\\d\\d");
		int i = 0;
		while (getline(this->inFile, s))								// 打开文件
		{

			if (++i == 13220) break;
			if (regex_search(s, m, r))							// 匹配条件为 True 进入
				if (regex_search(s, m, regex("G\\d\\d")))		// 首行则进入
				{
					//cout << s.substr(0, 3) ;
					prn.push_back(s.substr(0, 3));				// 将卫星 prn 推入
					vt.push_back(vi);							// 将之前的遍历作为一个推入 vt	
					vi.clear();									// 清空vi，为下一次遍历做准备
					for (sregex_iterator it(s.begin() + 3, s.end(), r1), end_it; it != end_it; ++it)	// sregex_iterator 正则迭代作用
						vi.push_back(stold(it->str()));			// 将匹配的每一个参数转为浮点型再推入vi
				}
				else
					for (sregex_iterator it(s.begin(), s.end(), r1),
						end_it; it != end_it; ++it) vi.push_back(stold(it->str()));	// 将匹配的每一个参数转为浮点型再推入vi
						
		}
		vt.push_back(vi);	// 将最后一次遍历的值推入 vt
		// 写入文档首行条目
		this->oFile << "prn"<<","<<"gpstime"<< ","<<"n" << "," << "tk" << "," << "mk" << "," << "ek" << "," << "vk" << "," << "pa" << "," << "cu" << "," <<
			"cr" << "," << "ci" << "," << "uk" << "," << "rk" << "," << "ik" << "," << "xk" << "," << "yk" << "," << "dk" <<
			"," << "Xk" << "," << "Yk" << "," << "Zk" << endl;

	}
	else cout << "打开文件失败！请关闭 Excel 后重试！" << endl;	// 若文件打开失败则提示

	for (int i = 1; i < vt.size(); i++)	// 将数据存储在变量
	{
		//cout << i << endl;
		this->prn = prn[i - 1];
		this->year = vt[i][0];
		this->month = vt[i][1];
		this->day = vt[i][2];
		this->hour = vt[i][3];
		this->min = vt[i][4];
		this->second = vt[i][5];

		this->af0 = vt[i][6];
		this->af1 = vt[i][7];
		this->af2 = vt[i][8];
		/*
		cout << "shijain" << endl;
		cout<<this->year<<"  ";
		cout<<this->month<<" ";
		cout<<this->day <<" ";
		cout<<this->hour<<" ";
		cout<<this->min<<" ";
		cout<<this->second<<endl;
		*/
		this->IODE = vt[i][9];
		this->Crs = vt[i][10];
		this->a_poor = vt[i][11];
		this->m0 = vt[i][12];

		this->Cuc = vt[i][13];
		this->e = vt[i][14];
		this->Cus = vt[i][15];
		this->sqrtA = vt[i][16];

		this->toe = vt[i][17];
		this->Cic = vt[i][18];
		this->Ra0 = vt[i][19];
		this->Cis = vt[i][20];

		this->i0 = vt[i][21];
		this->Crc = vt[i][22];
		this->w = vt[i][23];
		this->Ra = vt[i][24];

		this->i = vt[i][25];
		this->L2 = vt[i][26];
		this->g_week = vt[i][27];
		this->L2P = vt[i][28];

		this->acc = vt[i][29];
		this->state = vt[i][30];
		this->Tgd = vt[i][31];
		this->IDOC = vt[i][32];

		//this->s_time = vt[i][33];
		//this->f_val = vt[i][34];

		this->calData();		// 计算数据
		this->wdata();			// 存储中间数据
	}
		this->lglrchazhi(path2,path3);

}

// 析构函数，关闭文件
Satellites::~Satellites()
{
	this->inFile.close();		// 关闭文件
	this->oFile.close();				// 关闭文件
}

// 计算数据函数
void Satellites::calData()
{
	this->n = sqrt(U) / pow(this->sqrtA, 3) + this->a_poor; //	计算平均角速度 n
	//cout << "gpst  " << this->getgpst('s');
	//cout << "toe " << this->toe;
	this->gpstime = this->getgpst('s');
	this->tk = this->getgpst('s') - this->toe;	//	计算归化时间 tk
	//cout << "tkshijain  " << this->tk<<endl;
	this->mk = this->m0 + (this->n * this->tk);				// 观测时间 mk
	this->ek = this->mk;									// 计算偏近角
	long double temp = 0;
	while (fabs(this->ek - temp) > 0.10e-12)
	{
		temp = this->ek;
		this->ek = this->mk + (this->e * sin(temp));
	}

//(1)  轨道平面坐标系下卫星坐标
	this->vk = atan((sqrt(1 - pow(this->e, 2)) * sin(this->ek) / (cos(this->ek) - this->e)));			// 计算真近角 vk
	this->pa = this->vk + this->w;																		// 计算升交距角
	this->cu = (this->Cuc * cos(2 * this->pa)) + (this->Cus * sin(2 * this->pa));						// 计算摄动改正项
	this->cr = (this->Crc * cos(2 * this->pa)) + (this->Crs * sin(2 * this->pa));
	this->ci = (this->Cic * cos(2 * this->pa)) + (this->Cis * sin(2 * this->pa));
	this->uk = this->pa + this->cu;																		// 计算经过摄动改正的参数
	this->rk = pow(this->sqrtA, 2) * (1 - this->e * cos(this->ek)) + this->cr;
	this->ik = this->i0 + this->ci + (this->i * this->tk);
	this->xk = this->rk * cos(this->uk);																// 轨道平面直角坐标系中的坐标
	this->yk = this->rk * sin(this->uk);

//(2)轨道平面坐标系转换地心地固系坐标系 

	this->dk = this->Ra0 + ((this->Ra - E) * this->tk) - (this->Ra * this->toe);//公式修改								// 升交点经度计算
	this->Xk = this->xk * cos(this->dk) - (this->yk * cos(this->ik) * sin(this->dk));					// 计算在地心固定坐标系中的直角坐标
	this->Yk = this->xk * sin(this->dk) + (this->yk * cos(this->ik) * sin(this->dk));
	this->Zk = this->yk * sin(this->ik);
}



// c = 'w' 则返回 gps 周， c = 's' 则返回 gpa 周内秒，默认返回周内秒

// 将数据写入文件
void Satellites::wdata()
{
	//cout << this->prn << endl;
	this->oFile<< this->prn<< "," << this->gpstime << "," << this->n << "," << this->tk << "," << this->mk << "," << this->ek << ","
		<< this->vk << "," << this->pa << "," << this->cu << "," << this->cr <<
		"," << this->ci << "," << this->uk << "," << this->rk << "," << this->ik
		<< "," << this->xk << "," << this->yk << "," << this->dk << "," << this->Xk <<
		"," << this->Yk << "," << this->Zk << endl;
}


// 计算每一年的天数
int Satellites::ydcount(int year)
{
	int count = 0;
	if (year == 1980)	count = 360;													// 若是 1980 年的话，按照算法 360 天
	else if ((year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0))	count = 366;	// 若是闰年，则 1 年有 366 天
	else	count = 365;																// 若平闰年，则 1 年有 365 天
	return count;
}

// 计算一年中每个月的天数
int Satellites::ydcount(int year, int month)
{
	int count = 0;																			// 存储每个月的天数
	if (year == 1980 && month == 1) count = 25;												// 根据算法，1980 年 1 月算作 25 天
	else if (month == 4 || month == 6 || month == 9 || month == 11) count = 30;				// 四六九冬 30 整
	else if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) count = 31;
	else
	{
		if ((year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0))	count = 29;			// 若是闰年，则 2 月有 29 天
		else count = 28;
	}
	return count;

}
long double Satellites::getgpst(char c = 's')
{
	if (c != 'w' && c != 's') return -1;											// 若传递的参数不正确，则返回-1
	int days = this->day;
	for (int i = 1980; i < this->year; i++)	days += ydcount(i);						// 计算年天数
	for (int i = 1; i < this->month; i++)	days += ydcount(this->year, i);			// 计算月天数
	return c == 'w' ? days / 7 : (days % 7) * 86400 + (this->hour * 3600) + (this->min * 60) + this->second;
}





string Satellites:: gpsSeconds2Time(long long gpsSeconds)
{
	//cout << "getw " << this->getgpst('s')<<endl;
	time_t utcTime = gpsSeconds+this->getgpst('w')* 604800+ 315964800; // 转化为utc
	struct tm utcTm = { 0 };
	gmtime_s(&utcTm, &utcTime); // 将UTC时间转化为可读时间

	char buffer[20];
	sprintf_s(buffer, "%04d-%02d-%02d %02d:%02d:%02d", utcTm.tm_year + 1900, utcTm.tm_mon + 1, utcTm.tm_mday,
		utcTm.tm_hour, utcTm.tm_min, utcTm.tm_sec);

	string timeStr(buffer);
	return timeStr;
}



// 以逗号为分隔符，将一行数据解析为一个vector<string>
vector<string> parseLine(const string& line) {
	vector<string> result;
	stringstream ss(line);
	string cell;
	while (getline(ss, cell, ',')) {
		result.push_back(cell);
	}
	return result;
}

// 读取CSV文件，返回一个二维vector<string>
vector<vector<string>> readCSV(const string& filename) {
	vector<vector<string>> result;
	ifstream file(filename);
	if (file.is_open()) {
		string line;
		while (getline(file, line)) {
			result.push_back(parseLine(line));
		}
		file.close();
	}
	return result;
}


//对坐标进行每隔15分钟的线性插值
void Satellites::lglrchazhi(string path2,string path3)
{
	vector<vector<string>> data = readCSV(path2);//读入已知数据   data为所有数据
	//for (auto row : data) {
	//	for (auto cell : row) {
	//		cout << cell << " ";
	//	}
	//	cout << endl;
	//}
	vector<vector<string>> Weixing_jiesuan;     //筛选出要算的数据
	for (int i = 1; i < data.size(); i++) { // 从第二行开始遍历   
		vector<string> newRow;
		newRow.push_back(data[i][0]); // 第一列
		newRow.push_back(data[i][1]); // 第二列
		newRow.push_back(data[i][17]); // 第18列
		newRow.push_back(data[i][18]); // 第19列
		newRow.push_back(data[i][19]); // 第20列
		Weixing_jiesuan.push_back(newRow);
	}

	// 拉格朗日线性插值
	double x, y;
	vector<vector<string>> WX_cz;     //

	for (int i = 2; i < Weixing_jiesuan.size(); i++) {
		string name1 = Weixing_jiesuan[i - 1][0], name2 = Weixing_jiesuan[i][0];
		//cout << "weixingming1 " << name1 << "weixingming2 " << name2 << endl;
		if (name1==name2)
		{//同一个卫星才进行插值操作
			double x1 = stod(Weixing_jiesuan[i - 1][1]), x2 = stod(Weixing_jiesuan[i][1]);//线性插值间隔
			double X1 = stod(Weixing_jiesuan[i - 1][2]), X2 = stod(Weixing_jiesuan[i][2]);//获得间隔坐标值
			double Y1 = stod(Weixing_jiesuan[i - 1][3]), Y2 = stod(Weixing_jiesuan[i][3]);
			double Z1 = stod(Weixing_jiesuan[i - 1][4]), Z2 = stod(Weixing_jiesuan[i][4]);
			for (double j = x1; j < x2; j += 900) { // 每隔900秒进行插值
				double k = (j - x1) / (x2 - x1);
				double X = X1 * (1 - k) + X2 * k;   //插值坐标
				double Y = Y1 * (1 - k) + Y2 * k;
				double Z = Z1 * (1 - k) + Z2 * k;
				//cout << name1 << " shijian" << j << " zuobiao  " << X << " " << Y << " " << endl;

				//依据GPS秒转换年月日存储，增加可读性

				vector<string> newRow2;
				newRow2.push_back(name1);
				cout << "time " << gpsSeconds2Time(j)<<endl;
				newRow2.push_back(gpsSeconds2Time(j));
				newRow2.push_back(to_string(j));
				newRow2.push_back(to_string(X));
				newRow2.push_back(to_string(Y));
				newRow2.push_back(to_string(Z));
				WX_cz.push_back(newRow2);
				i++;

			}
		}

	}
		//将结果存入文件
		ofstream out(path3);
		out << "prn" << "," <<"time"<<"," << "gpstime" << "," << "X" << "," << "Y" << "," << "Z" << endl;
		for (auto row : WX_cz) {
			for (auto cell : row) {
				out << cell << ",";
			}
			out << endl;
		}
		out.close();

		cout << "已将排序后的结果保存在"<<path3<<" 文件中。" << endl;

		//for (const auto& row : WX_cz) {
		//	for (const auto& col : row) {
		//		cout << col << " ";
		//	}
		//	cout << endl;
		//}

		//

}
